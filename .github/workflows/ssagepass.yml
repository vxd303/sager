name: build-ssagepass-ndk

on:
  push: { branches: [ main ] }
  pull_request: { branches: [ main ] }
  workflow_dispatch:

permissions: { contents: read }

env:
  SSAGEPASS_REPO: https://github.com/lux-QAQ/SsagePass.git
  SSAGEPASS_REF: ""

jobs:
  build-and-ndk:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install host LLVM14 + deps
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y llvm-14 llvm-14-dev llvm-14-tools clang-14
          sudo apt-get install -y libc++1-14 libc++abi1-14 libc++-14-dev libc++abi-14-dev
          sudo apt-get install -y ninja-build cmake git curl file

      - name: Set host toolchain env
        run: |
          echo "HOST_LLVM_DIR=/usr/lib/llvm-14/lib/cmake/llvm" >> "$GITHUB_ENV"
          echo "CC=clang-14"  >> "$GITHUB_ENV"
          echo "CXX=clang-14" >> "$GITHUB_ENV"

      - name: Clone SsagePass
        id: clone
        run: |
          set -euxo pipefail
          mkdir -p third_party && cd third_party
          git clone --depth=1 --branch main "${SSAGEPASS_REPO}" SsagePass
          cd SsagePass
          if [ -n "${SSAGEPASS_REF}" ]; then
            git fetch origin "${SSAGEPASS_REF}" && git checkout FETCH_HEAD
          fi
          echo "src_dir=$PWD" >> "$GITHUB_OUTPUT"
          find . -maxdepth 2 -print

      - name: Detect CMakeLists (Obfuscation preferred)
        id: detect
        run: |
          set -euxo pipefail
          SRC="${{ steps.clone.outputs.src_dir }}"
          if [ -f "$SRC/Obfuscation/CMakeLists.txt" ]; then
            BUILD_DIR="$SRC/Obfuscation"
          else
            readarray -t CANDS < <(find "$SRC" -type f -name CMakeLists.txt -printf '%h\n' | sort -u)
            BUILD_DIR="${CANDS[0]:-}"
          fi
          test -n "$BUILD_DIR" || { echo "::error::No CMakeLists found"; exit 1; }
          echo "build_dir=$BUILD_DIR" >> "$GITHUB_OUTPUT"
          nl -ba "$BUILD_DIR/CMakeLists.txt" | sed -n '1,160p'

      - name: Patch PMRegistration.cpp (enable passes at O0 & O1+)
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          F="$D/src/PMRegistration.cpp"
          cat > "$F" <<'CPP'
          #include "llvm/IR/PassManager.h"
          #include "llvm/Passes/PassBuilder.h"
          #include "llvm/Passes/PassPlugin.h"
          #include "llvm/Support/raw_ostream.h"

          // Pass headers
          #include "Flattening.h"
          #include "FlatteningEnhanced.h"
          #include "SplitBasicBlock.h"
          #include "BogusControlFlow.h"
          #include "StringEncryption.h"
          #include "MBAObfuscation.h"
          #include "FunctionWrapper.h"
          #include "VMFlatten.h"
          #include "IndirectBranch.h"
          #include "IndirectCall.h"

          using namespace llvm;

          static void addSsageFunctionPipeline(FunctionPassManager &FPM) {
            // Thứ tự tương đối an toàn; mỗi pass tự kiểm tra annotation của hàm.
            FPM.addPass(FlatteningEnhancedPass());
            FPM.addPass(FlatteningPass());
            FPM.addPass(SplitBasicBlockPass());
            FPM.addPass(BogusControlFlowPass());
            FPM.addPass(MBAObfuscationPass());
            FPM.addPass(FunctionWrapperPass());
            FPM.addPass(VMFlattenPass());
            FPM.addPass(IndirectBranchPass());
            FPM.addPass(IndirectCallPass());
            FPM.addPass(StringEncryptionPass());
          }

          static void addSsageModulePipeline(ModulePassManager &MPM) {
            FunctionPassManager FPM;
            addSsageFunctionPipeline(FPM);
            MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));
          }

          extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() {
            return {
              LLVM_PLUGIN_API_VERSION, "SsageObfuscator", "14",
              [](PassBuilder &PB) {
                // In ra một dòng để bạn thấy plugin được nạp
                errs() << "[Ssage] Pass plugin loaded (hooks: Start, OptimizerEarly)\n";

                // Chạy cả ở O0
                PB.registerPipelineStartEPCallback(
                  [](ModulePassManager &MPM, PassBuilder::OptimizationLevel) {
                    addSsageModulePipeline(MPM);
                  });

                // Và chạy đầu pipeline tối ưu (O1+)
                PB.registerOptimizerEarlyEPCallback(
                  [](ModulePassManager &MPM, PassBuilder::OptimizationLevel) {
                    addSsageModulePipeline(MPM);
                  });

                // (tuỳ chọn) Bạn có thể thêm PB.registerPipelineParsingCallback
                // để hỗ trợ -passes="function(ssage-...)" nếu muốn.
              }
            };
          }
          CPP

      - name: Sanitize CMakeLists + set C++17, libc++, includes
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          cp "$D/CMakeLists.txt" "$D/CMakeLists.txt.orig" || true

          # Gỡ hardcode, thêm include LLVM và libc++
          sed -i -E \
            -e 's|^set\(CMAKE_C_COMPILER .*$|# [CI] patched|' \
            -e 's|^set\(CMAKE_CXX_COMPILER .*$|# [CI] patched|' \
            -e 's|^set\(ENV\{LLVM_HOME\} .*$|# [CI] patched|' \
            -e 's|^set\(ENV\{LLVM_DIR\} .*$|# [CI] patched|' \
            -e '/ndk-llvm\/out\/install\/linux-x86\/clang-dev\/include/d' \
            "$D/CMakeLists.txt" || true

          grep -q 'find_package(LLVM' "$D/CMakeLists.txt" || printf '\nfind_package(LLVM REQUIRED CONFIG)\n' >> "$D/CMakeLists.txt"
          grep -q 'CMAKE_CXX_STANDARD' "$D/CMakeLists.txt" || printf '\nset(CMAKE_CXX_STANDARD 17)\n' >> "$D/CMakeLists.txt"
          grep -q 'LLVM_INCLUDE_DIRS' "$D/CMakeLists.txt"   || printf '\ninclude_directories(${LLVM_INCLUDE_DIRS})\n' >> "$D/CMakeLists.txt"
          grep -q '/usr/include/c++/v1' "$D/CMakeLists.txt" || printf '\ninclude_directories(/usr/include/c++/v1)\n' >> "$D/CMakeLists.txt"

          # đảm bảo -fno-rtti & link libc++
          {
            echo ''
            echo 'if (TARGET SsageObfuscator)'
            echo '  target_compile_options(SsageObfuscator PRIVATE -fno-rtti)'
            echo '  target_link_libraries(SsageObfuscator PRIVATE c++ c++abi)'
            echo 'endif()'
          } >> "$D/CMakeLists.txt"

          grep -q 'CMAKE_CXX_FLAGS' "$D/CMakeLists.txt" || printf '\nset(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")\n' >> "$D/CMakeLists.txt"
          grep -q 'CMAKE_SHARED_LINKER_FLAGS' "$D/CMakeLists.txt" || printf '\nset(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -stdlib=libc++ -Wl,-rpath,/usr/lib")\n' >> "$D/CMakeLists.txt"

      - name: Clean build/
        run: rm -rf build

      - name: Configure (host LLVM14; C++17)
        env:
          LLVM_DIR: ${{ env.HOST_LLVM_DIR }}
          CC: ${{ env.CC }}
          CXX: ${{ env.CXX }}
        run: |
          set -euo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          cmake -S "$D" -B build -G Ninja \
            -DLLVM_DIR="${LLVM_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER="${CC}" \
            -DCMAKE_CXX_COMPILER="${CXX}" \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_CXX_FLAGS="-stdlib=libc++" \
            -DCMAKE_SHARED_LINKER_FLAGS="-stdlib=libc++ -Wl,-rpath,/usr/lib"

      - name: Build plugin
        run: cmake --build build -j"$(nproc)"

      - name: Locate plugin
        id: find_plugin
        run: |
          set -eux
          f=$(find build -type f -name "*SsageObfuscator*.so" -o -name "SsageObfuscator.so" | head -n1 || true)
          test -n "$f" || { echo "::error::plugin .so not found"; find build -maxdepth 3 -type f -printf '%p\n'; exit 1; }
          echo "plugin=$f" >> "$GITHUB_OUTPUT"
          echo "Using plugin: $f"
          ls -l "$f" && file "$f"

      # ---- (tuỳ chọn) Build host IR để quan sát biến đổi IR trực tiếp ----
      - name: Host IR test (emit-llvm, O2)
        run: |
          set -euxo pipefail
          PLUGIN="${{ steps.find_plugin.outputs.plugin }}"
          cat > host_ir_test.cpp <<'EOF'
          #include <cstdio>
          __attribute__((noinline))
          __attribute__((__annotate__("fla")))
          __attribute__((__annotate__("split")))
          __attribute__((__annotate__("bcf")))
          __attribute__((__annotate__("mba")))
          __attribute__((__annotate__("funcwrap")))
          __attribute__((__annotate__("vmf")))
          __attribute__((__annotate__("indibr")))
          __attribute__((__annotate__("icall")))
          __attribute__((__annotate__("strenc")))
          static void g() {
            std::puts("Hello Obf!");
          }
          int main(){ g(); return 0; }
          EOF
          clang++-14 -S -emit-llvm -O2 -fpass-plugin="$PLUGIN" host_ir_test.cpp -o host_ir_test.ll
          head -n 60 host_ir_test.ll || true

      # ---- NDK test (không dùng -mllvm; O2 để chắc OptimizerEarly chạy) ----
      - name: Setup NDK r25c
        id: setup-ndk
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r25c
          add-to-path: true

      - name: NDK compile test – annotations only (O2)
        run: |
          set -euxo pipefail
          PLUGIN="${{ steps.find_plugin.outputs.plugin }}"
          NDK="${{ steps.setup-ndk.outputs.ndk-path }}"
          CXX="$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++"
          "$CXX" --version

          cat > test_ndk.cpp <<'EOF'
          #include <cstdio>
          __attribute__((noinline))
          __attribute__((__annotate__("fla")))
          __attribute__((__annotate__("split")))
          __attribute__((__annotate__("bcf")))
          __attribute__((__annotate__("mba")))
          __attribute__((__annotate__("funcwrap")))
          __attribute__((__annotate__("vmf")))
          __attribute__((__annotate__("indibr")))
          __attribute__((__annotate__("icall")))
          __attribute__((__annotate__("strenc")))
          static void ultra(){ std::puts("NDK obf check"); }
          int main(){ ultra(); return 0; }
          EOF

          "$CXX" --target=aarch64-linux-android31 -O2 -fPIC \
            -fpass-plugin="$PLUGIN" \
            -c test_ndk.cpp -o test_ndk.o

          "$CXX" --target=aarch64-linux-android31 test_ndk.o -shared -o libtest_ndk.so
          file libtest_ndk.so || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ssagepass-ndk-artifacts
          path: |
            ${{ steps.find_plugin.outputs.plugin }}
            ${{ steps.detect.outputs.build_dir }}/CMakeLists.txt
            ${{ steps.detect.outputs.build_dir }}/CMakeLists.txt.orig
            PMRegistration.cpp
            host_ir_test.cpp
            host_ir_test.ll
            test_ndk.cpp
            test_ndk.o
            libtest_ndk.so
