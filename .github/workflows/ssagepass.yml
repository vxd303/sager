name: build-ssagepass-ndk

on:
  push: { branches: [ main ] }
  pull_request: { branches: [ main ] }
  workflow_dispatch:

permissions: { contents: read }

env:
  SSAGEPASS_REPO: https://github.com/lux-QAQ/SsagePass.git
  SSAGEPASS_REF: ""   # pin SHA/branch nếu muốn

jobs:
  build-and-ndk:
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install host LLVM14 + deps (for building plugin)
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y llvm-14 llvm-14-dev llvm-14-tools clang-14
          sudo apt-get install -y libc++1-14 libc++abi1-14 libc++-14-dev libc++abi-14-dev
          sudo apt-get install -y ninja-build cmake git curl file

      - name: Set host toolchain env
        run: |
          echo "HOST_LLVM_DIR=/usr/lib/llvm-14/lib/cmake/llvm" >> "$GITHUB_ENV"
          echo "CC=clang-14"  >> "$GITHUB_ENV"
          echo "CXX=clang-14" >> "$GITHUB_ENV"

      - name: Clone SsagePass
        id: clone
        run: |
          set -euxo pipefail
          mkdir -p third_party && cd third_party
          git clone --depth=1 --branch main "${SSAGEPASS_REPO}" SsagePass
          cd SsagePass
          if [ -n "${SSAGEPASS_REF}" ]; then
            git fetch origin "${SSAGEPASS_REF}" && git checkout FETCH_HEAD
          fi
          echo "src_dir=$PWD/Obfuscation" >> "$GITHUB_OUTPUT"
          find . -maxdepth 2 -print

      - name: Detect build dir (Obfuscation)
        id: detect
        shell: bash
        run: |
          set -euxo pipefail
          SRC="${{ steps.clone.outputs.src_dir }}"
          test -f "$SRC/CMakeLists.txt" || { echo "::error::No CMakeLists in $SRC"; exit 1; }
          echo "build_dir=$SRC" >> "$GITHUB_OUTPUT"

      # (tuỳ repo của bạn đã từng vá, bạn có thể giữ/loại các patch dưới đây)
      - name: Quick compatibility patch set (LLVM14)
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          # Bật C++17 nếu cần
          if grep -qE 'CMAKE_CXX_STANDARD' "$D/CMakeLists.txt"; then
            sed -i -E 's/CMAKE_CXX_STANDARD[[:space:]]+[0-9]+/CMAKE_CXX_STANDARD 17/' "$D/CMakeLists.txt"
          else
            printf '\nset(CMAKE_CXX_STANDARD 17)\n' >> "$D/CMakeLists.txt"
          fi
          # StringRef::starts_with -> startswith (LLVM14)
          find "$D" -type f \( -name '*.cpp' -o -name '*.h' \) -print0 \
            | xargs -0 sed -i 's/\.starts_with(/.startswith(/g' || true
          # Thêm <optional> khi dùng std::optional/nullopt
          mapfile -t OPT_FILES < <(grep -RIl --include='*.{cpp,h}' -e 'std::optional' -e 'std::nullopt' "$D" || true)
          for f in "${OPT_FILES[@]}"; do
            grep -qE '^[[:space:]]*#include <optional>' "$f" || sed -i '1i #include <optional>' "$f"
          done

      - name: Build strip-inline-asm plugin (ABI-safe)
        shell: bash
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          STRIP_DIR="$ROOT/stripper"
          NDK=/opt/hostedtoolcache/ndk/r25c/x64
          HOST_CLANGXX="$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++"
      
          mkdir -p "$STRIP_DIR"
      
          cat > "$STRIP_DIR/CMakeLists.txt" <<'CMAKE'
          cmake_minimum_required(VERSION 3.13)
          project(StripInlineAsm LANGUAGES C CXX)
          enable_language(C)
          set(CMAKE_CXX_STANDARD 17)
          set(CMAKE_POSITION_INDEPENDENT_CODE ON)
          find_package(LLVM 14 REQUIRED CONFIG)
          include_directories(${LLVM_INCLUDE_DIRS})
          add_definitions(${LLVM_DEFINITIONS})
          add_library(StripInlineAsm MODULE
            StripInlineAsm.cpp
            Register.cpp
          )
          # Dùng libc++ để khớp ABI với clang++ NDK
          target_compile_options(StripInlineAsm PRIVATE -stdlib=libc++)
          target_link_options(StripInlineAsm PRIVATE -stdlib=libc++ -Wl,-rpath,/usr/lib -Wl,-rpath,/usr/lib/llvm-14/lib)
          target_compile_definitions(StripInlineAsm PRIVATE -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS)
          target_include_directories(StripInlineAsm PRIVATE ${LLVM_INCLUDE_DIRS})
          if (NOT LLVM_ENABLE_RTTI)
            target_compile_options(StripInlineAsm PRIVATE -fno-rtti)
          endif()
          set_target_properties(StripInlineAsm PROPERTIES
            OUTPUT_NAME "StripInlineAsm"
            PREFIX "lib"
          )
          CMAKE
      
          cat > "$STRIP_DIR/StripInlineAsm.h" <<'HDR'
          #pragma once
          #include "llvm/IR/PassManager.h"
          namespace llvm {
          class StripInlineAsmPass : public PassInfoMixin<StripInlineAsmPass> {
          public:
            PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
          };
          } // namespace llvm
          HDR
      
          cat > "$STRIP_DIR/StripInlineAsm.cpp" <<'CPP'
          #include "StripInlineAsm.h"
          #include "llvm/ADT/Triple.h"
          #include "llvm/IR/InlineAsm.h"
          #include "llvm/IR/IRBuilder.h"
          #include "llvm/IR/Module.h"
          #include "llvm/Support/raw_ostream.h"
          using namespace llvm;
      
          PreservedAnalyses StripInlineAsmPass::run(Module &M, ModuleAnalysisManager &) {
            Triple TT(M.getTargetTriple());
            // Giữ inline asm nếu target là x86/x64
            if (TT.isX86()) {
              errs() << "[StripInlineAsm] target is x86 — keep inline asm\n";
              return PreservedAnalyses::all();
            }
            errs() << "[StripInlineAsm] running on target " << TT.str() << "\n";
            bool Changed = false;
      
            // 1) Xoá module-level inline asm
            if (!M.getModuleInlineAsm().empty()) {
              errs() << "[StripInlineAsm] cleared module inline asm (size="
                     << (unsigned)M.getModuleInlineAsm().size() << ")\n";
              M.setModuleInlineAsm("");
              Changed = true;
            }
      
            // 2) Xoá các call InlineAsm trong function
            for (Function &F : M) {
              for (auto &BB : F) {
                for (auto I = BB.begin(), E = BB.end(); I != E;) {
                  Instruction *Inst = &*I++;
                  if (auto *CB = dyn_cast<CallBase>(Inst)) {
                    Value *Callee = CB->getCalledOperand()->stripPointerCasts();
                    if (isa<InlineAsm>(Callee)) {
                      errs() << "[StripInlineAsm] remove inline asm call in " << F.getName() << "\n";
                      if (!CB->getType()->isVoidTy())
                        CB->replaceAllUsesWith(UndefValue::get(CB->getType()));
                      CB->eraseFromParent();
                      Changed = true;
                    }
                  }
                }
              }
            }
            return Changed ? PreservedAnalyses::none() : PreservedAnalyses::all();
          }
          CPP
      
          cat > "$STRIP_DIR/Register.cpp" <<'CPP'
          #include "StripInlineAsm.h"
          #include "llvm/Passes/PassBuilder.h"
          #include "llvm/Passes/PassPlugin.h"
          using namespace llvm;
      
          extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() {
            return {
              LLVM_PLUGIN_API_VERSION, "StripInlineAsm", "1.0",
              [](PassBuilder &PB) {
                // Đầu pipeline
                PB.registerPipelineStartEPCallback(
                  [](ModulePassManager &MPM, OptimizationLevel) {
                    MPM.addPass(StripInlineAsmPass());
                  });
                // Cuối pipeline
                PB.registerOptimizerLastEPCallback(
                  [](ModulePassManager &MPM, OptimizationLevel) {
                    MPM.addPass(StripInlineAsmPass());
                  });
              }
            };
          }
          CPP
  
          cmake -S "$STRIP_DIR" -B "$STRIP_DIR/build" -G Ninja \
            -DLLVM_DIR="/usr/lib/llvm-14/lib/cmake/llvm" \
            -DCMAKE_C_COMPILER=clang-14 \
            -DCMAKE_CXX_COMPILER="$HOST_CLANGXX" \
            -DCMAKE_CXX_FLAGS="-stdlib=libc++" \
            -DCMAKE_SHARED_LINKER_FLAGS="-stdlib=libc++ -Wl,-rpath,/usr/lib -Wl,-rpath,/usr/lib/llvm-14/lib" \
            -DCMAKE_DISABLE_FIND_PACKAGE_Terminfo=ON \
            -DCMAKE_DISABLE_FIND_PACKAGE_FFI=ON
      
          cmake --build "$STRIP_DIR/build" -j"$(nproc)"
          echo "strip_plugin=$STRIP_DIR/build/libStripInlineAsm.so" >> "$GITHUB_OUTPUT"

      
          #### 4) Ép đăng ký vào PMRegistration.cpp (đầu và cuối pipeline)
          f="$D/src/PMRegistration.cpp"
          test -f "$f" || { echo "::error::PMRegistration.cpp not found: $f"; exit 1; }
      
          # Bổ sung include
          grep -q 'StripInlineAsm.h' "$f" || \
            perl -0777 -i -pe 's/#include\s*<llvm\/Passes\/PassBuilder\.h>\s*\n/#include <llvm\/Passes\/PassBuilder.h>\n#include "StripInlineAsm.h"\n/s' "$f"
      
          # Chèn 2 callback ngay SAU khi mở ngoặc của lambda có tham số PassBuilder& PB
          # (dùng 2 lần re để tăng độ bền với format khác nhau).
          perl -0777 -i -pe '
            my $add = qq{
              PB.registerPipelineStartEPCallback([](ModulePassManager &MPM, OptimizationLevel){
                MPM.addPass(StripInlineAsmPass());
              });
              PB.registerOptimizerLastEPCallback([](ModulePassManager &MPM, OptimizationLevel){
                MPM.addPass(StripInlineAsmPass());
              });
            };
            s/(\(\s*PassBuilder\s*&\s*PB\s*\)\s*\{)/$1\n$add/s or
            s/(\[\s*\]\s*\(\s*PassBuilder\s*&\s*PB\s*\)\s*\{)/$1\n$add/s;
            $_;
          ' "$f"
      
          echo "== verify insert =="
          grep -n 'StripInlineAsmPass' "$f" || true
          grep -n 'StripInlineAsm.cpp' "$cmake_file" || true

      # >>>>>>>>>>>>>>>>>>>> QUAN TRỌNG: thay PMRegistration.cpp cho NPM <<<<<<<<<<<<<<<<<<<<
      - name: Replace PMRegistration.cpp (register passes in NPM)
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          F="$D/src/PMRegistration.cpp"
          cat > "$F" <<'CPP'
          #include "llvm/Passes/PassBuilder.h"
          #include "llvm/Passes/PassPlugin.h"
          #include "llvm/IR/PassManager.h"
          #include "llvm/Support/raw_ostream.h"

          // Our passes
          #include "Flattening.h"
          #include "FlatteningEnhanced.h"
          #include "SplitBasicBlock.h"
          #include "BogusControlFlow.h"
          #include "MBAObfuscation.h"
          #include "FunctionWrapper.h"
          #include "VMFlatten.h"
          #include "IndirectBranch.h"
          #include "IndirectCall.h"
          #include "StringEncryption.h"

          using namespace llvm;

          // Đăng ký plugin cho LLVM 14
          extern "C" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK
          llvmGetPassPluginInfo() {
            return {
              LLVM_PLUGIN_API_VERSION, "SsageObfuscator", "14",
              [](PassBuilder &PB) {
                // In ra banner một lần đầu pipeline
                PB.registerPipelineStartEPCallback(
                  [](ModulePassManager &MPM, OptimizationLevel OL) {
                    (void)OL;
                    llvm::outs() << "Version is 25\n";
                    llvm::outs() << "Made By SsageParuders\n";

                    // 1) Module-level passes (flag=false -> chỉ chạy khi có annotation)
                    MPM.addPass(FlatteningEnhanced(/*flag=*/false));
                    MPM.addPass(StringEncryptionPass(/*flag=*/false));
                    MPM.addPass(IndirectBranchPass(/*flag=*/false));
                    MPM.addPass(FunctionWrapperPass(/*flag=*/false));

                    // 2) Function-level passes (gói vào adaptor)
                    FunctionPassManager FPM;
                    FPM.addPass(FlatteningPass(/*flag=*/false));       // "ofla"
                    FPM.addPass(SplitBasicBlockPass(/*flag=*/false));   // "split"
                    FPM.addPass(BogusControlFlowPass(/*flag=*/false));  // "bcf"
                    FPM.addPass(MBAObfuscation(/*flag=*/false));        // "mba"
                    FPM.addPass(IndirectCallPass(/*flag=*/false));      // "icall"
                    FPM.addPass(VMFlattenPass(/*flag=*/false, /*optLevel=*/0)); // "vmf"

                    MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));
                  }
                );
              }
            };
          }
          CPP
          
      - name: Sanitize CMakeLists (drop all set_target_properties; add includes, -fno-rtti, link c++/c++abi)
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          cp "$D/CMakeLists.txt" "$D/CMakeLists.txt.orig" || true

          echo "=== HEAD (original) ==="
          nl -ba "$D/CMakeLists.txt" | sed -n '1,120p' || true

          # 1) Bỏ hardcode compiler/ENV nếu có
          sed -i -E \
            -e 's|^set\(CMAKE_C_COMPILER .*$|# [CI] patched|' \
            -e 's|^set\(CMAKE_CXX_COMPILER .*$|# [CI] patched|' \
            -e 's|^set\(ENV\{LLVM_HOME\} .*$|# [CI] patched|' \
            -e 's|^set\(ENV\{LLVM_DIR\} .*$|# [CI] patched|' \
            "$D/CMakeLists.txt" || true

          # 2) XÓA TOÀN BỘ set_target_properties(...) (mọi biến thể, đa dòng)
          perl -0777 -pe 's/set_target_properties\s*\([\s\S]*?\)\s*//g' -i "$D/CMakeLists.txt"

          # 3) Bảo đảm C++17 + include thư mục LLVM & libc++
          grep -q 'find_package(LLVM' "$D/CMakeLists.txt" || printf '\nfind_package(LLVM REQUIRED CONFIG)\n' >> "$D/CMakeLists.txt"
          if grep -qE 'CMAKE_CXX_STANDARD' "$D/CMakeLists.txt"; then
            sed -i -E 's/CMAKE_CXX_STANDARD[[:space:]]+[0-9]+/CMAKE_CXX_STANDARD 17/' "$D/CMakeLists.txt"
          else
            printf '\nset(CMAKE_CXX_STANDARD 17)\n' >> "$D/CMakeLists.txt"
          fi
          grep -q 'LLVM_INCLUDE_DIRS' "$D/CMakeLists.txt" || printf '\ninclude_directories(${LLVM_INCLUDE_DIRS})\n' >> "$D/CMakeLists.txt"
          grep -q '/usr/include/c++/v1' "$D/CMakeLists.txt" || printf '\ninclude_directories(/usr/include/c++/v1)\n' >> "$D/CMakeLists.txt"

          # 4) Thêm -fno-rtti bằng target_compile_options (nếu target tồn tại)
          {
            echo ''
            echo '# [CI] ensure -fno-rtti'
            echo 'if (TARGET SsageObfuscator)'
            echo '  target_compile_options(SsageObfuscator PRIVATE -fno-rtti)'
            echo 'endif()'
          } >> "$D/CMakeLists.txt"

          # 5) Link libc++/c++abi cho target plugin
          if grep -q 'add_library[[:space:]]*\([[:space:]]*SsageObfuscator' "$D/CMakeLists.txt"; then
            awk '
              { print }
              /^add_library[[:space:]]*\([[:space:]]*SsageObfuscator/ { inlib=1 }
              inlib && /^\)/ { print "target_link_libraries(SsageObfuscator PRIVATE c++ c++abi)"; inlib=0 }
            ' "$D/CMakeLists.txt" > "$D/CMakeLists.txt.ci" && mv "$D/CMakeLists.txt.ci" "$D/CMakeLists.txt"
          fi

          # 6) Thêm flags mặc định khi build
          grep -q 'CMAKE_CXX_FLAGS' "$D/CMakeLists.txt" || printf '\nset(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")\n' >> "$D/CMakeLists.txt"
          grep -q 'CMAKE_SHARED_LINKER_FLAGS' "$D/CMakeLists.txt" || printf '\nset(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -stdlib=libc++ -Wl,-rpath,/usr/lib")\n' >> "$D/CMakeLists.txt"

          echo "=== HEAD (sanitized) ==="
          nl -ba "$D/CMakeLists.txt" | sed -n '1,160p' || true
      - name: Patch Utils.cpp (LLVM14 Demote* expects Instruction*)
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          F="$D/src/Utils.cpp"
          test -f "$F" || { echo "::error::Utils.cpp not found"; exit 1; }

          # Đảm bảo có <optional>
          grep -qE '^[[:space:]]*#include <optional>' "$F" || sed -i '1i #include <optional>' "$F"

          # DemotePHIToStack(PN, insertPoint) --> DemotePHIToStack(PN, insertPoint ? &*insertPoint.value() : nullptr)
          perl -0777 -pe 's/DemotePHIToStack\s*\(\s*PN\s*,\s*insertPoint\s*\)/DemotePHIToStack(PN, insertPoint ? \&\*insertPoint.value() : nullptr)/g' -i "$F"

          # DemoteRegToStack(*I, false, insertPoint) --> DemoteRegToStack(*I, false, insertPoint ? &*insertPoint.value() : nullptr)
          perl -0777 -pe 's/DemoteRegToStack\s*\(\s*\*I\s*,\s*false\s*,\s*insertPoint\s*\)/DemoteRegToStack(*I, false, insertPoint ? \&\*insertPoint.value() : nullptr)/g' -i "$F"

          echo "=== Context around patched lines ==="
          nl -ba "$F" | sed -n '150,210p'

      - name: Patch BogusControlFlow & VMFlatten for LLVM14 (iterator vs Instruction*)
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
      
          # ---- BogusControlFlow.cpp ----
          F="$D/src/BogusControlFlow.cpp"
          if [ -f "$F" ]; then
            # 1) BinaryOperator::Create(..., InsertBefore->getIterator()) -> InsertBefore (Instruction*)
            perl -0777 -pe 's/(\bBinaryOperator::Create\([^;]*?),\s*InsertBefore->getIterator\(\)\s*\)/$1, InsertBefore)/g' -i "$F"
      
            # 2) So sánh với begin()/end(): đổi Instruction* sang iterator bằng ->getIterator()
            perl -0777 -pe 's/getFirstNonPHIOrDbgOrLifetime\(\)\s*(==|!=)\s*([A-Za-z_][A-Za-z0-9_\->]*)\bend\(\)/getFirstNonPHIOrDbgOrLifetime()->getIterator() $1 \2end()/g' -i "$F"
            perl -0777 -pe 's/getFirstNonPHIOrDbgOrLifetime\(\)\s*(==|!=)\s*([A-Za-z_][A-Za-z0-9_\->]*)\bbegin\(\)/getFirstNonPHIOrDbgOrLifetime()->getIterator() $1 \2begin()/g' -i "$F"
      
            # 3) Gán iterator từ Instruction*: thêm ->getIterator();
            perl -0777 -pe 's/(\b[A-Za-z_]\w*\s*=\s*[A-Za-z_]\w*\s*->\s*getFirstNonPHIOrDbgOrLifetime\(\))\s*;/\1->getIterator();/g' -i "$F"
      
            echo "=== BogusControlFlow.cpp (context) ==="
            nl -ba "$F" | sed -n '100,140p'
            nl -ba "$F" | sed -n '340,380p'
          fi
      
          # ---- VMFlatten.cpp ----
          F="$D/src/VMFlatten.cpp"
          if [ -f "$F" ]; then
            # DemotePHIToStack(phi, insertionPoint) -> DemotePHIToStack(phi, &*insertionPoint)
            perl -0777 -pe 's/DemotePHIToStack\s*\(\s*([^\),]+)\s*,\s*insertionPoint\s*\)/DemotePHIToStack(\1, \&*insertionPoint)/g' -i "$F"
            # (nếu có) DemoteRegToStack(..., false, insertionPoint) -> ... , &*insertionPoint)
            perl -0777 -pe 's/DemoteRegToStack\s*\(\s*([^\),]+)\s*,\s*false\s*,\s*insertionPoint\s*\)/DemoteRegToStack(\1, false, \&*insertionPoint)/g' -i "$F"
      
            echo "=== VMFlatten.cpp (context) ==="
            nl -ba "$F" | sed -n '810,840p'
          fi

      - name: Patch IPObfuscationContext for LLVM14 (splice BasicBlock list)
        shell: bash
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          F="$D/src/IPObfuscationContext.cpp"
          test -f "$F" || exit 0
      
          # Trường hợp hay gặp: NF->splice(NF->begin(), F);
          sed -i 's/NF->splice(NF->begin(), F);/NF->getBasicBlockList().splice(NF->getBasicBlockList().begin(), F->getBasicBlockList());/' "$F" || true
      
          # Vá tổng quát: X->splice(X->begin(), Y)  ->  X->getBasicBlockList().splice(X->getBasicBlockList().begin(), Y->getBasicBlockList())
          perl -0777 -pe 's/(\b[A-Za-z_]\w*)->splice\(\s*\1->begin\(\)\s*,\s*([A-Za-z_]\w*)\s*\)/$1->getBasicBlockList().splice($1->getBasicBlockList().begin(), $2->getBasicBlockList())/g' -i "$F"
      
          # Nếu lỡ dùng dấu chấm (biến không phải con trỏ) thì cũng chuyển tương tự
          perl -0777 -pe 's/(\b[A-Za-z_]\w*)\.splice\(\s*\1\.begin\(\)\s*,\s*([A-Za-z_]\w*)\s*\)/$1.getBasicBlockList().splice($1.getBasicBlockList().begin(), $2.getBasicBlockList())/g' -i "$F"
      
          # Chuẩn hoá: mọi 'X.getBasicBlockList()' về 'X->getBasicBlockList()' nếu X là con trỏ
          sed -i -E 's/([A-Za-z_]\w*)\.getBasicBlockList\(\)/\1->getBasicBlockList()/g' "$F"
      
          echo "=== Patched context (around line ~215) ==="
          nl -ba "$F" | sed -n '200,235p'

      - name: Configure (host LLVM14)
        env:
          LLVM_DIR: ${{ env.HOST_LLVM_DIR }}
          CC: ${{ env.CC }}
          CXX: ${{ env.CXX }}
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"
          cmake -S "$D" -B build -G Ninja \
            -DLLVM_DIR="${LLVM_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER="${CC}" \
            -DCMAKE_CXX_COMPILER="${CXX}" \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_CXX_FLAGS="-stdlib=libc++" \
            -DCMAKE_SHARED_LINKER_FLAGS="-stdlib=libc++ -Wl,-rpath,/usr/lib"

      - name: Build plugin
        run: cmake --build build -j"$(nproc)"

      - name: Locate plugin
        id: find_plugin
        run: |
          set -euxo pipefail
          f=$(find build -type f -name "*SsageObfuscator*.so" -o -name "SsageObfuscator.so" | head -n1 || true)
          test -n "$f" || { echo "::error::plugin .so not found"; exit 1; }
          echo "plugin=$f" >> "$GITHUB_OUTPUT"
          ls -l "$f" && file "$f"

      # Nếu thiếu symbol xchacha20_poly1305_encrypt thì chèn stub *phi bảo mật* để CI không fail
      - name: Add xchacha fallback & rebuild (no heredoc)
        shell: bash
        run: |
          set -euxo pipefail
          D="/home/runner/work/sager/sager/third_party/SsagePass/Obfuscation"
          SO="build/libSsageObfuscator.so"
          echo "Checking undefined symbols in: $SO"
          if nm -u "$SO" | c++filt | grep -q 'xchacha20_poly1305_encrypt'; then
            echo ">> Adding fallback stub for xchacha20_poly1305_encrypt (NON-CRYPTO)"
            F="$D/src/ci_xchacha_fallback.cpp"
            : > "$F"
            # Ghi file C++ bằng printf để tránh here-doc
            printf '%s\n' \
              '#include <vector>' \
              '#include <cstdint>' \
              '// Fallback NON-CRYPTO: copy plaintext, tag = 16 zero bytes. For CI only.' \
              'void xchacha20_poly1305_encrypt(' \
              '  const std::vector<unsigned char>& plaintext,' \
              '  const std::vector<unsigned char>& key,' \
              '  const std::vector<unsigned char>& nonce,' \
              '  const std::vector<unsigned char>& ad,' \
              '  std::vector<unsigned char>& ciphertext,' \
              '  std::vector<unsigned char>& tag' \
              '){' \
              '  (void)key; (void)nonce; (void)ad;' \
              '  ciphertext = plaintext;' \
              '  tag.assign(16, 0);' \
              '}' >> "$F"
      
            # Thêm nguồn vào target nếu chưa có
            grep -q 'ci_xchacha_fallback.cpp' "$D/CMakeLists.txt" || \
              printf '\n# CI fallback for xchacha\ntarget_sources(SsageObfuscator PRIVATE ${CMAKE_CURRENT_LIST_DIR}/src/ci_xchacha_fallback.cpp)\n' >> "$D/CMakeLists.txt"
      
            # Rebuild .so
            cmake -S "$D" -B build -G Ninja \
              -DLLVM_DIR="/usr/lib/llvm-14/lib/cmake/llvm" \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_C_COMPILER="clang-14" \
              -DCMAKE_CXX_COMPILER="clang-14" \
              -DCMAKE_CXX_STANDARD=17 \
              -DCMAKE_CXX_FLAGS="-stdlib=libc++" \
              -DCMAKE_SHARED_LINKER_FLAGS="-stdlib=libc++ -Wl,-rpath,/usr/lib"
            cmake --build build -j"$(nproc)"
      
            NEW_SO="$(readlink -f "$(find build -type f -name "*SsageObfuscator*.so" -o -name "SsageObfuscator.so" | head -n1)")"
            echo "plugin=$NEW_SO" >> "$GITHUB_OUTPUT"
            echo "Rebuilt plugin: $NEW_SO"
            echo "Undefined symbols now:"
            nm -u "$NEW_SO" | c++filt || true
          else
            echo ">> xchacha symbol already resolved; skip fallback."
          fi

      - name: Setup NDK r25c
        id: setup-ndk
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r25c
          add-to-path: true

      - name: Patch crypto_runtime.cpp (C++17 + portable syscall)
        shell: bash
        run: |
          set -euxo pipefail
          D="/home/runner/work/sager/sager/third_party/SsagePass/Obfuscation"
          F="$D/src/crypto_runtime.cpp"
      
          # Bổ sung headers nếu thiếu
          add_inc() { grep -qF "$1" "$F" || sed -i "1i $1" "$F"; }
          add_inc '#include <unistd.h>'
          add_inc '#include <sys/syscall.h>'
          add_inc '#include <sys/ptrace.h>'
          add_inc '#include <sys/mman.h>'
      
          # Chuẩn hoá macro SYS_* nếu môi trường chỉ có __NR_*
          perl -0777 -i -pe '
          BEGIN{$x=qq(
          #ifndef SYS_MPROTECT
          #define SYS_MPROTECT __NR_mprotect
          #endif
          #ifndef SYS_READLINKAT
          #define SYS_READLINKAT __NR_readlinkat
          #endif
          #ifndef SYS_UNLINKAT
          #define SYS_UNLINKAT __NR_unlinkat
          #endif
          #ifndef SYS_WRITE
          #define SYS_WRITE __NR_write
          #endif
          #ifndef SYS_PTRACE
          #define SYS_PTRACE __NR_ptrace
          #endif
          );}
          s!(#include\s*<sys/syscall\.h>.*?\n)!$1$x!s
          ' "$F"
              # Thay toàn bộ định nghĩa hàm direct_syscall… (loại bỏ inline asm + C++20)
              perl -0777 -i -pe '
          s!
          static\s+long\s+NO_IC_INSTRUMENT\s+direct_syscall\s*\([^)]*\)\s*\{
          .*?
          ^\}
          !template <typename... Args>
          static long NO_IC_INSTRUMENT direct_syscall(long number, Args... args) {
           // Dùng syscall(2) portable cho x86-64/aarch64; cast về long cho an toàn ABI.
           return (long)::syscall(number, (long)args...);
          }
          !msx
          ' "$F"
      - name: Build crypto_runtime.bc (NDK toolchain, fix SYS_* redefines)
        shell: bash
        run: |
          set -euxo pipefail
          D="${{ steps.detect.outputs.build_dir }}"   # Obfuscation dir
          NDK="${{ steps.setup-ndk.outputs.ndk-path }}"
          BIN="$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin"
          CXX="$BIN/clang++"
          CC="$BIN/clang"
          LLVMLINK="$BIN/llvm-link"   # dùng llvm-link của NDK (14.0.7)
      
          # (Nếu trước đó bạn có bước patch C++20->C++17 + direct_syscall() dùng ::syscall,
          #  hãy giữ nguyên — không cần lặp lại ở đây.)
      
          # 2) Đường include cho headers
          INC1="-I$D/include"
          INC2="-I$D/black3"
      
          # 3) Biên dịch từng phần sang LLVM bitcode bằng NDK 14.0.7
          mkdir -p "$HOME/.ollvm"
          "$CXX" --target=aarch64-linux-android31 -std=gnu++17 -O2 -fPIC -emit-llvm -c \
            $INC1 $INC2 "$D/src/crypto_runtime.cpp" -o "$HOME/.ollvm/crypto_runtime_core.bc"
      
          "$CC"  --target=aarch64-linux-android31 -O2 -fPIC -emit-llvm -c $INC2 \
            "$D/black3/blake3.c"              -o "$HOME/.ollvm/blake3.c.bc"
          "$CC"  --target=aarch64-linux-android31 -O2 -fPIC -emit-llvm -c $INC2 \
            "$D/black3/blake3_dispatch.c"     -o "$HOME/.ollvm/blake3_dispatch.c.bc"
          "$CC"  --target=aarch64-linux-android31 -O2 -fPIC -emit-llvm -c $INC2 \
            "$D/black3/blake3_portable.c"     -o "$HOME/.ollvm/blake3_portable.c.bc"
      
          # 4) Link các .bc bằng llvm-link của NDK (đúng version)
          "$LLVMLINK" \
            "$HOME/.ollvm/crypto_runtime_core.bc" \
            "$HOME/.ollvm/blake3.c.bc" \
            "$HOME/.ollvm/blake3_dispatch.c.bc" \
            "$HOME/.ollvm/blake3_portable.c.bc" \
            -o "$HOME/.ollvm/crypto_runtime.bc"
      
          # 5) Một số plugin còn dò cả ở CWD → tạo symlink cho chắc
          ln -sf "$HOME/.ollvm/crypto_runtime.bc" ./crypto_runtime.bc
      
          echo "Built bitcode:"
          ls -l "$HOME/.ollvm/crypto_runtime.bc" ./crypto_runtime.bc

      # 1) Build plugin 'stripper' – xoá inline asm
      - name: Build strip-inline-asm plugin
        shell: bash
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          STRIP_DIR="$ROOT/stripper"
          mkdir -p "$STRIP_DIR"
      
          cat > "$STRIP_DIR/CMakeLists.txt" <<'CMAKE'
          cmake_minimum_required(VERSION 3.13)
          project(StripInlineAsm LANGUAGES C CXX)
          enable_language(C)
          set(CMAKE_CXX_STANDARD 17)
          set(CMAKE_POSITION_INDEPENDENT_CODE ON)
          find_package(LLVM 14 REQUIRED CONFIG)
          include_directories(${LLVM_INCLUDE_DIRS})
          add_definitions(${LLVM_DEFINITIONS})
          add_library(StripInlineAsm MODULE
            StripInlineAsm.cpp
            Register.cpp
          )
          target_compile_definitions(StripInlineAsm PRIVATE -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS)
          target_include_directories(StripInlineAsm PRIVATE ${LLVM_INCLUDE_DIRS})
          if (NOT LLVM_ENABLE_RTTI)
            target_compile_options(StripInlineAsm PRIVATE -fno-rtti)
          endif()
          set_target_properties(StripInlineAsm PROPERTIES
            OUTPUT_NAME "StripInlineAsm"
            PREFIX "lib"
          )
          CMAKE
      
          cat > "$STRIP_DIR/StripInlineAsm.h" <<'HDR'
          #pragma once
          #include "llvm/IR/PassManager.h"
          namespace llvm {
          class StripInlineAsmPass : public PassInfoMixin<StripInlineAsmPass> {
          public:
            PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
          };
          } // namespace llvm
          HDR
      
          cat > "$STRIP_DIR/StripInlineAsm.cpp" <<'CPP'
          #include "StripInlineAsm.h"
          #include "llvm/ADT/Triple.h"
          #include "llvm/IR/InlineAsm.h"
          #include "llvm/IR/IRBuilder.h"
          #include "llvm/IR/Module.h"
          #include "llvm/Support/raw_ostream.h"
          using namespace llvm;
      
          PreservedAnalyses StripInlineAsmPass::run(Module &M, ModuleAnalysisManager &) {
            Triple TT(M.getTargetTriple());
            if (TT.isX86()) {
              errs() << "[StripInlineAsm] target is x86 — keep inline asm\n";
              return PreservedAnalyses::all();
            }
            errs() << "[StripInlineAsm] running on target " << TT.str() << "\n";
            bool Changed = false;
      
            if (!M.getModuleInlineAsm().empty()) {
              errs() << "[StripInlineAsm] cleared module inline asm (size="
                     << (unsigned)M.getModuleInlineAsm().size() << ")\n";
              M.setModuleInlineAsm("");
              Changed = true;
            }
      
            for (Function &F : M) {
              for (auto &BB : F) {
                for (auto I = BB.begin(), E = BB.end(); I != E;) {
                  Instruction *Inst = &*I++;
                  if (auto *CB = dyn_cast<CallBase>(Inst)) {
                    Value *Callee = CB->getCalledOperand()->stripPointerCasts();
                    if (isa<InlineAsm>(Callee)) {
                      errs() << "[StripInlineAsm] remove inline asm call in " << F.getName() << "\n";
                      if (!CB->getType()->isVoidTy())
                        CB->replaceAllUsesWith(UndefValue::get(CB->getType()));
                      CB->eraseFromParent();
                      Changed = true;
                    }
                  }
                }
              }
            }
            return Changed ? PreservedAnalyses::none() : PreservedAnalyses::all();
          }
          CPP
      
          cat > "$STRIP_DIR/Register.cpp" <<'CPP'
          #include "StripInlineAsm.h"
          #include "llvm/Passes/PassBuilder.h"
          #include "llvm/Passes/PassPlugin.h"
          using namespace llvm;
      
          extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() {
            return {
              LLVM_PLUGIN_API_VERSION, "StripInlineAsm", "1.0",
              [](PassBuilder &PB) {
                PB.registerPipelineStartEPCallback(
                  [](ModulePassManager &MPM, OptimizationLevel) {
                    MPM.addPass(StripInlineAsmPass());
                  });
                PB.registerOptimizerLastEPCallback(
                  [](ModulePassManager &MPM, OptimizationLevel) {
                    MPM.addPass(StripInlineAsmPass());
                  });
              }
            };
          }
          CPP
      
          cmake -S "$STRIP_DIR" -B "$STRIP_DIR/build" -G Ninja \
            -DLLVM_DIR="/usr/lib/llvm-14/lib/cmake/llvm" \
            -DCMAKE_C_COMPILER=clang-14 \
            -DCMAKE_CXX_COMPILER=clang-14 \
            -DCMAKE_DISABLE_FIND_PACKAGE_Terminfo=ON \
            -DCMAKE_DISABLE_FIND_PACKAGE_FFI=ON
      
          cmake --build "$STRIP_DIR/build" -j"$(nproc)"
          echo "strip_plugin=$STRIP_DIR/build/libStripInlineAsm.so" >> "$GITHUB_OUTPUT"

      
      # 2) Biên dịch test với CẢ HAI plugin
      - name: NDK test with both plugins (Ssage + strip)
        shell: bash
        env:
          PLUGIN: build/libSsageObfuscator.so
          STRIP_PLUGIN: ${{ steps.build-strip-inline-asm-plugin.outputs.strip_plugin || 'stripper/build/libStripInlineAsm.so' }}
        run: |
          set -euo pipefail
          NDK="/opt/hostedtoolcache/ndk/r25c/x64"
          CXX="$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++"
          "$CXX" --version
      
          cat > test_max.cpp <<'EOF'
          #include <cstdio>
          __attribute__((noinline))
          static void ultra(){ std::puts("NDK MAX obf (annotated)"); }
      
          __attribute__((noinline))
          static void ultra2(){ std::puts("NDK MAX obf 2 (annotated)"); }
      
          int main(){ ultra(); ultra2(); return 0; }
          EOF
      
          # NẠP 2 PLUGIN — tụi nó đều hook PB, pass strip sẽ chạy ở đầu/cuối
          "$CXX" --target=aarch64-linux-android31 -O0 -fPIC \
            -fpass-plugin="$PLUGIN" \
            -fpass-plugin="$STRIP_PLUGIN" \
            -c test_max.cpp -o test_max.o
      
          "$CXX" --target=aarch64-linux-android31 test_max.o -shared -o libtest_max.so
          file libtest_max.so || true

      - name: NDK compile test — annotations (NEW PM, -O0)
        run: |
          set -euxo pipefail
          PLUGIN="${{ steps.stub_xchacha.outputs.plugin || steps.find_plugin.outputs.plugin }}"
          NDK="${{ steps.setup-ndk.outputs.ndk-path }}"
          CXX="${NDK}/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++"
          "$CXX" --version

          cat > test_max.cpp <<'EOF'
          #include <cstdio>
          __attribute__((noinline))
          __attribute((__annotate__(("ofla enfla split strenc bcf mba funwra vmf indibr icall"))))
          static void ultra(){ std::puts("NDK MAX obf (annotated)"); }

          __attribute__((noinline))
          __attribute((__annotate__(("ofla enfla split strenc bcf mba funwra vmf indibr icall"))))
          static void ultra2(){ std::puts("NDK MAX obf 2 (annotated)"); }

          int main(){ ultra(); ultra2(); return 0; }
          EOF

          "$CXX" --target=aarch64-linux-android31 -O0 -fPIC \
            -fpass-plugin="$PLUGIN" \
            -c test_max.cpp -o test_max.o
          "$CXX" --target=aarch64-linux-android31 test_max.o -shared -o libtest_max.so
          file libtest_max.so || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ssagepass-ndk-artifacts
          path: |
            ${{ steps.find_plugin.outputs.plugin }}
            ${{ steps.detect.outputs.build_dir }}/CMakeLists.txt
            ${{ steps.detect.outputs.build_dir }}/CMakeLists.txt.orig
            ${{ github.workspace }}/test_max.cpp
            ${{ github.workspace }}/test_max.o
            ${{ github.workspace }}/libtest_max.so
